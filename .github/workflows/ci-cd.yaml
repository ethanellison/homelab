name: CI/CD Pipeline

on:
  pull_request:
    branches: [main]
  workflow_dispatch: {}

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Validate Kubernetes manifests
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          ./kustomize version

          # Validate Kubernetes manifests
          echo "Validating infrastructure manifests..."
          ./kustomize build infrastructure/kubernetes/base

          echo "Validating application manifests..."
          # ./kustomize build applications/kubernetes/base

          # Add more validation steps as needed

      - name: Validate Docker Compose files
        run: |
          # Install yq
          sudo apt-get update && sudo apt-get install -y yq

          # Install Docker Compose V2
          DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
          mkdir -p $DOCKER_CONFIG/cli-plugins
          curl -SL https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
          chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose

          ROOT="applications/compose"

          validate_host() {
            HOST=$1
            echo "Validating $HOST environment compose files..."
            
            SERVICES=$(yq -r '.services[]' "$ROOT/environments/$HOST/services.yaml")
            
            FILES=""
            for S in $SERVICES; do
              FILES="$FILES -f $ROOT/base/$S/compose.yaml"
            done
            
            FILES="$FILES -f $ROOT/environments/$HOST/docker-compose.yaml"
            
            docker compose $FILES config
          }

          validate_host local
          validate_host vps

  deploy:
    needs: validate
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    concurrency: production_environment

    steps:
      - uses: actions/checkout@v6

      - name: Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          ping: srv715735.dzo-byzantine.ts.net
      - name: Setup SSH_PRIVATE_KEY
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "srv715735.dzo-byzantine.ts.net" >> ~/.ssh/known_hosts

      - name: Install yq
        run: |
          sudo apt-get update && sudo apt-get install -y yq

      - name: Deploy to VPS
        env:
          HOST: srv715735.dzo-byzantine.ts.net
          USERNAME: root
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          HOST_ENV="vps"
          ROOT="applications/compose"

          # 1. Get the list of services to deploy
          SERVICES=$(yq -r '.services[]' "$ROOT/environments/$HOST_ENV/services.yaml")
          echo "Deploying services: $SERVICES"

          # 2. Use SSH and pass the services list as an environment variable to the remote shell
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new root@srv715735.dzo-byzantine.ts.net 'set -euo pipefail
            echo "âœ… Connected to host and preparing secrets"

            SERVICES="'"$SERVICES"'"
            PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

            # Create secure temp files for the env bundle and the GPG passphrase
            TEMP_ENV_FILE="$(mktemp /tmp/homelab-secrets.XXXXXXXX.env)"
            GPG_PASSPHRASE_FILE="$(mktemp /tmp/homelab-gpg-passphrase.XXXXXXXX)"
            chmod 600 "$TEMP_ENV_FILE" "$GPG_PASSPHRASE_FILE"

            # Guarantee cleanup of both temp files even if the script exits early
            trap "rm -f \"$TEMP_ENV_FILE\" \"$GPG_PASSPHRASE_FILE\"" EXIT

            # Write passphrase via printf to avoid leaking it in process args
            printf "%s" "${{ secrets.GPG_PASSPHRASE }}" > "$GPG_PASSPHRASE_FILE"

            # Ensure gpg-agent allows loopback pinentry (required for non-interactive symmetric decrypt)
            mkdir -p "$HOME/.gnupg"
            chmod 700 "$HOME/.gnupg"
            touch "$HOME/.gnupg/gpg-agent.conf"
            chmod 600 "$HOME/.gnupg/gpg-agent.conf"
            if ! grep -qs "^allow-loopback-pinentry$" "$HOME/.gnupg/gpg-agent.conf"; then
              printf "%s\n" "allow-loopback-pinentry" >> "$HOME/.gnupg/gpg-agent.conf"
            fi
            gpgconf --launch gpg-agent || true
            gpgconf --reload gpg-agent || true

            # Tell pass to forward loopback + passphrase-file to gpg (keeps passphrase out of ps output)
            export PASSWORD_STORE_GPG_OPTS="--batch --yes --quiet --pinentry-mode loopback --passphrase-file $GPG_PASSPHRASE_FILE"

            # Base CI secrets
            pass show github/ci > "$TEMP_ENV_FILE"

            # Service-specific secrets (naming convention: homelab/vps/<service>)
            for SERVICE in $SERVICES; do
              if [ -f "$PASSWORD_STORE_DIR/homelab/vps/${SERVICE}.gpg" ]; then
                echo "Decrypting secrets for service: ${SERVICE}"
                pass show "homelab/vps/${SERVICE}" >> "$TEMP_ENV_FILE"
                printf "\n" >> "$TEMP_ENV_FILE"
              else
                echo "No specific secret found for service: ${SERVICE}"
              fi
            done

            cd /opt/homelab
            git pull origin main
            chmod +x scripts/**/*.sh
            ./scripts/setup/init-dev-environment.sh docker

            # Deploy using the securely decrypted environment file
            HOMELAB_ENV_FILE="$TEMP_ENV_FILE" ./scripts/deploy/deploy-compose.sh vps up'
